**Описание еще не полностью отредактировано!** Собираю материалы для readme.

Для запуска нужно перейти в корень проекта и запустить команду **docker compose up -d** (Либо запустить с Visual Studio Code)<br>
Для тестирования API нужно перейти по ссылке: http://localhost:8080/swagger<br>

___

<h3>Архитектура</h3>

Данное решение реализует **Clean architecture**.

<img width="500" height="576" alt="image" src="https://github.com/user-attachments/assets/45e34ed1-0a30-4cf4-b2f2-debe30cbaa8d" />

- **domain** - слой, в котором определены сущности. Это, можно сказать, "ядро" приложения.<br>
- **application/usecases** - здесь находятся сервисы, которые работают с бизнес-логикой.<br>
- **infrastructure** - здесь находятся низкоуровневые сервисы. В данном случае реализации репозиториев.<br>
- **interfaces** - здесь находится контроллер http-запросов (обработчики, которые привязаны к маршрутам).<br>

___


<h3>База данных</h3>

В качестве БД используется **PostgreSQL**<br>
Определены следующие таблицы:<br>

- **USERS** - таблица пользователей<br>
- **TEAMS** - таблица команд<br>
- **TEAM_MEMBERS** - таблица с членами команд<br>
- **PULL_REQUESTS** - таблица с пулл-реквестами<br>
- **PULL_REQUEST_VIEWERS** - ревьюверы, привязанные к пулл-реквесту<br>

<br>

_ER-диаграмма:_

<img width="680" height="439" alt="image" src="https://github.com/user-attachments/assets/0c24f040-3c2a-43ea-bee2-38ef252fe364" />

<br>

_Миграции_:<br>

При запуске приложения после запуска контейнера с БД, проходят миграции. После чего инициализируются тестовые данные:<br>

- 3 команды: _backend_, _frontend_, _devops_<br>
- 100 пользователей, 13 из которых уже состоят в командах. Остальные свободны (можно привязать к новой команде).<br>
ID'ы всех пользователей задаются их порядковым номером: u1...u100 (uN).

___


<h2>Дополнительные задания</h2>

<h3>1. Нагрузочное тестирование</h3>
Для нагрузочного тестирования использовался **Apache JMeter**. Тесты проходили на эндпоинте /team/get.<br>
Было использовано 3 сценария: 100 пользователей, 1000 пользователей, 10000 пользователей. Ниже приведены результаты тестирования:

_100 пользователей:_ <br>
<img width="523" height="241" alt="image" src="https://github.com/user-attachments/assets/b5a6692f-1a85-4dfe-a9fd-fca27adb07b7" />

При нагрузке в 100 пользователей сервис справляется хорошо. APDEX близок к 1.

_1000 пользователей:_ <br>
<img width="522" height="240" alt="image" src="https://github.com/user-attachments/assets/d25e2f01-f262-445c-b02d-474aae55ac5b" />

При нагрузке в 1000 пользователей получаются средние показатели. APDEX близок к 0.6.


_10000 пользователей_ <br>
<img width="529" height="249" alt="image" src="https://github.com/user-attachments/assets/d571ed94-d9d1-4156-8bb8-5a6b2d4d5ddb" />

При нагрузке в 10000 пользователей сервис справляется слабо. Нужна оптимизация.<br>
Также были случаи, связанные с БД. Например, ошибки в логах:<br>
_FATAL:  sorry, too many clients already._ <br>
Изменил _max_connections=100_. Но это максимум по умолчанию. В дальнейшем потребуется масштабирование.<br>
Также не хватает индексов (но их не стал добавлять в начале, т.к. пока данных не слишком много). <br>

Но во всех 3 случаях не было ошибок в ответах:<br>
<img width="525" height="286" alt="image" src="https://github.com/user-attachments/assets/b3bda999-62cd-44e2-8eb2-0cbf84df52e5" />

Более подробную информацию можно посмотреть в каталоге _tests/load_.
